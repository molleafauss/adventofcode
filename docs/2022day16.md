## Using Advent of code 2022 day 16 to compare languages
For fun, I decided to port the solution to [Advent of code 2022, Day 16](https://adventofcode.com/2022/day/16) 
to few languages I know. Just to compare the results and see if I would find some surprises. 
Surprises happened.

The problem is complex, it's a recursive search algorithm that requires some memoization to 
reduce the time to completion, overall it definitely taxes memory and cpu in terms of sheer 
number of function calls and data memorized.

The four languages I ported the solution are:
* python (a language I know well enough, and it was the original I used for the challenge)
* Rust (I language I learned recently, and that I ported first the python version to)
* Java (my main language, the one I've worked the most in these past 25 years)
* Go (a recently learned language that I need for my new workplace)

> IMPORTANT CAVEATS: The algorithm used to solve the problem is for sure awful and can be 
> improved and optimised in many ways. The results below are quite interesting, though.

So what are the results? I tried to measure not only the time it took to solve the challenge, 
but tried to check cpu and memory used, just to make some comparison.

> machine used: Windows 11 - Intel Core i7-10875H CPU @ 2.30GHz - 32GB RAM

| LANGUAGE | SOLUTION TIME | CPU USAGE           | MEMORY PEAK        |
|----------|---------------|---------------------|--------------------|
| Python   | 450.8sec      | avg & peak 100%     | 16GB               | 
| Rust     | 583.9sec (*)  | avg & peak 100%     | 10GB (peaks at 16) | 
| Java     | 209.5sec      | avg 300%, peak 350% | 8.5GB              | 
| Go       | 169.6sec      | avg 100%, peak 500% | 10.2GB             |
(*) Rust takes ~30s to output the final result, due to running Drop on all allocated entities in
    the cache. Funny enough this delay happens only on windows.

Language versions:
* Python 3.12.8
* go version go1.23.3 windows/amd64
* rustc 1.83.0 (90b35a623 2024-11-26) stable-x86_64-pc-windows-msvc
* OpenJDK 64-Bit Server VM Corretto-21.0.2.13.1 (build 21.0.2+13-LTS, mixed mode, sharing)

But how? Rust should be the fastest! ... Hold yer horses, let's try some hypothesis.

* in Java and Go CPU peaks over 100%; the procedure is single-threaded, and there's no 
  concurrency involved. This suggests both languages' GC is using the other CPUs while the main 
  thread runs the program, minimizing pauses.
  * In fact, on java, when using the `-XX:+UseSerialGC` switch that uses the 
    serial/single-threaded GC, run time jump to 333secs and the CPU usage in fact flattens to 
    100%. Still, is faster than Rust :thinking_face: 
  * python has also a GC, but doesn't use multiple core for memory management.
  * Rust is not a GC language, so the main thread does all the allocation/deallocation 
    while the program runs; with over 100M calls happening, this might be the reason for the 
    slowness. The procedure was also copied from python and may not play nice with the strict 
    safety that Rust enforces.
* Memory: Java seems the most effective here, Go is close enough to Java, and Rust is similar, 
  with a small peak at 16GB, probably when the HashMap used for cache was being resized. 


